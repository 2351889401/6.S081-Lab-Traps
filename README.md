### 一、前言
从大二开始，对操作系统感兴趣，当时对着哈尔滨工业大学李治军老师的公开课学习。但是一方面实验的平台是基于 **linux** 的，很多基础指令都不会使用；另一方面，当时知识面薄弱，很多方面理解不足，导致对操作系统的学习处于一个比较低的水平。  
  
现在是研二了，正处于找工作的时间段，想着试试操作系统相关的开发，在朋友的推荐下开始学习 **6.S081** 相关的课程。随着学习的深入，发现操作系统内核实在是有太多太多精妙的设计，自己的能力可能远远不够操作系统内核的开发。  
  
但是无论怎样，这次把 **6.S081** 所有的实验完成，这个过程就当是圆自己的一个**小小梦想**吧！^_^  

我把 **Traps** 这个实验放在第一个是因为之前的3个实验已经过去蛮久了，有点没印象了，之后会慢慢补上的。然后所有的实验内容目前来说没有参考任何资源，所以可能有不对的地方，请大家批评指正。

### 二、关于环境配置和相关包的一些安装
当时安装的过程挺不容易，这里给出2个核心的参考链接：  
https://www2014.aspxhtml.com/post-23428/  
https://blog.csdn.net/ConstineWhy/article/details/123291723  
和一些重要的注意事项：  
  
* **ubuntu** 版本需要 20.04
* 更改阿里镜像源（安装一些包的时候能方便很多） 参考 https://developer.aliyun.com/mirror/ubuntu?spm=a2c6h.13651102.0.0.3e221b113ijmV6  
* 安装 **SSH** 、配置 **IP** （一方面，可以让虚拟机联网下载包；另一方面，我在本机上使用 **VScode** 远程完成实验，这样开发起来比较方便）  
* 安装 **RISC-V** 交叉编译工具和 **QEMU**

上面这些注意事项在给出的第一个参考链接里面都有对应的内容，如果遇到问题，再看第二个链接或者自行解决。这样，实验环境就ok啦。  

## 实验之前很重要的一点，一定要耐下心、好好看文档+内核源码（其实看英文文献尤其锻炼咱们的耐心，看不明白的就 **chat-gpt** 帮忙翻译），多思考这么设计的原因和结果，可能会有不一样的感悟。

### 三、Traps实验  

**1. RISC-V assembly (easy)**  
user/call.c源码
```
int g(int x) {
  return x+3;
}

int f(int x) {
  return g(x);
}

void main(void) {
  printf("%d %d\n", f(8)+1, 13);
  exit(0);
}
```  
其对应的汇编版本为  
```
0000000000000000 <g>:

int g(int x) {
   0:	1141                	addi	sp,sp,-16
   2:	e422                	sd	s0,8(sp)
   4:	0800                	addi	s0,sp,16
  return x+3;
}
   6:	250d                	addiw	a0,a0,3
   8:	6422                	ld	s0,8(sp)
   a:	0141                	addi	sp,sp,16
   c:	8082                	ret

000000000000000e <f>:

int f(int x) {
   e:	1141                	addi	sp,sp,-16
  10:	e422                	sd	s0,8(sp)
  12:	0800                	addi	s0,sp,16
  return g(x);
}
  14:	250d                	addiw	a0,a0,3
  16:	6422                	ld	s0,8(sp)
  18:	0141                	addi	sp,sp,16
  1a:	8082                	ret

000000000000001c <main>:

void main(void) {
  1c:	1141                	addi	sp,sp,-16
  1e:	e406                	sd	ra,8(sp)
  20:	e022                	sd	s0,0(sp)
  22:	0800                	addi	s0,sp,16
  printf("%d %d\n", f(8)+1, 13);
  24:	4635                	li	a2,13
  26:	45b1                	li	a1,12
  28:	00000517          	auipc	a0,0x0
  2c:	7c050513          	addi	a0,a0,1984 # 7e8 <malloc+0xea>
  30:	00000097          	auipc	ra,0x0
  34:	610080e7          	jalr	1552(ra) # 640 <printf>
  exit(0);
  38:	4501                	li	a0,0
  3a:	00000097          	auipc	ra,0x0
  3e:	27e080e7          	jalr	638(ra) # 2b8 <exit>
```
(1) 哪些寄存器包含了 **printf** 函数的参数？  
答：根据之前阅读的材料《**Calling Convention**》和此处的汇编代码，可以看到，寄存器 **a0** 、 **a1** 、 **a2** 包含了分别包含了 **printf** 的3个参数。  
  
(2)**f** 、 **g** 函数在 **main** 函数中的调用情况  
答：根据汇编代码，**f** 、 **g** 函数的调用过程似乎被编译器优化掉了。（这个有点不太确定）  

(3) **printf** 函数的地址  
答：0x640。
```
0000000000000640 <printf>:

void
printf(const char *fmt, ...)
{
 640:	711d                	addi	sp,sp,-96
 642:	ec06                	sd	ra,24(sp)
 644:	e822                	sd	s0,16(sp)
```

(4) **main** 函数中的 '**jalr**' 指令跳转到 **printf** 函数中去之后， **ra**（return address）寄存器值是多少？  
答：（本问是通过gdb查看的）在执行'**jalr**' 指令之前， **ra** 值是0x30，也就是上面的指令 “auipc ra, 0x0” 的地址；  
执行'**jalr**' 指令之后，**ra** 值是0x38，也就是上面的指令 “li a0, 0” 的地址。  

(5)代码段
```
unsigned int i = 0x00646c72;
printf("H%x Wo%s", 57616, &i);
```
的输出是什么？能产生该输出是在RISC-V是小端（little-endian）的条件下，如果是在大端（big-endian）的条件下，需要对“57616”和“i”的值做出改变吗？
